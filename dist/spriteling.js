(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global.Spriteling = factory());
}(this, (function () { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */

    var __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    /*
     * Modified version of http://github.com/desandro/imagesloaded v2.1.1
     * MIT License. by Paul Irish et al.
     */

    var BLANK = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==';

    function loaded(image, callback) {
      var src
        , old
        ;

      if (!image.nodeName) return callback(new Error('First argument must be an image element'))
      if (image.nodeName.toLowerCase() !== 'img') return callback(new Error('Element supplied is not an image'))
      if (image.src  && image.complete && image.naturalWidth !== undefined) return callback(null, true)

      old = !image.addEventListener;

      function loaded() {
        if (old) {
          image.detachEvent('onload', loaded);
        } else {
          image.removeEventListener('load', loaded, false);
        }
        callback(null, false);
      }

      if (old) {
        image.attachEvent('onload', loaded);
      } else {
        image.addEventListener('load', loaded, false);
      }

      if (image.readyState || image.complete) {
        src = image.src;
        image.src = BLANK;
        image.src = src;
      }
    }

    var imageLoaded = loaded;

    var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var performanceNow = createCommonjsModule(function (module) {
    // Generated by CoffeeScript 1.12.2
    (function() {
      var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

      if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
        module.exports = function() {
          return performance.now();
        };
      } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
        module.exports = function() {
          return (getNanoSeconds() - nodeLoadTime) / 1e6;
        };
        hrtime = process.hrtime;
        getNanoSeconds = function() {
          var hr;
          hr = hrtime();
          return hr[0] * 1e9 + hr[1];
        };
        moduleLoadTime = getNanoSeconds();
        upTime = process.uptime() * 1e9;
        nodeLoadTime = moduleLoadTime - upTime;
      } else if (Date.now) {
        module.exports = function() {
          return Date.now() - loadTime;
        };
        loadTime = Date.now();
      } else {
        module.exports = function() {
          return new Date().getTime() - loadTime;
        };
        loadTime = new Date().getTime();
      }

    }).call(commonjsGlobal);

    //# sourceMappingURL=performance-now.js.map
    });

    var root = typeof window === 'undefined' ? commonjsGlobal : window
      , vendors = ['moz', 'webkit']
      , suffix = 'AnimationFrame'
      , raf = root['request' + suffix]
      , caf = root['cancel' + suffix] || root['cancelRequest' + suffix];

    for(var i = 0; !raf && i < vendors.length; i++) {
      raf = root[vendors[i] + 'Request' + suffix];
      caf = root[vendors[i] + 'Cancel' + suffix]
          || root[vendors[i] + 'CancelRequest' + suffix];
    }

    // Some versions of FF have rAF but not cAF
    if(!raf || !caf) {
      var last = 0
        , id = 0
        , queue = []
        , frameDuration = 1000 / 60;

      raf = function(callback) {
        if(queue.length === 0) {
          var _now = performanceNow()
            , next = Math.max(0, frameDuration - (_now - last));
          last = next + _now;
          setTimeout(function() {
            var cp = queue.slice(0);
            // Clear queue here to prevent
            // callbacks from appending listeners
            // to the current frame's queue
            queue.length = 0;
            for(var i = 0; i < cp.length; i++) {
              if(!cp[i].cancelled) {
                try{
                  cp[i].callback(last);
                } catch(e) {
                  setTimeout(function() { throw e }, 0);
                }
              }
            }
          }, Math.round(next));
        }
        queue.push({
          handle: ++id,
          callback: callback,
          cancelled: false
        });
        return id
      };

      caf = function(handle) {
        for(var i = 0; i < queue.length; i++) {
          if(queue[i].handle === handle) {
            queue[i].cancelled = true;
          }
        }
      };
    }

    var raf_1 = function(fn) {
      // Wrap in a new function to prevent
      // `cancel` potentially being assigned
      // to the native rAF function
      return raf.call(root, fn)
    };
    var cancel = function() {
      caf.apply(root, arguments);
    };
    var polyfill = function(object) {
      if (!object) {
        object = root;
      }
      object.requestAnimationFrame = raf;
      object.cancelAnimationFrame = caf;
    };
    raf_1.cancel = cancel;
    raf_1.polyfill = polyfill;

    var playheadDefaults = {
        play: true,
        delay: 50,
        tempo: 1,
        run: -1,
        reversed: false,
        script: [],
        lastTime: 0,
        nextDelay: 0,
        currentFrame: -1,
        currentSprite: 1,
        onPlay: null,
        onStop: null,
        onFrame: null,
        onOutOfView: null
    };
    var Spriteling = /** @class */ (function () {
        /**
         * Creates a new Spriteling instance. The options object can contain the following values
         * - url: url to spriteSheet, if not set the css background-image will be used
         * - cols: number columns in the spritesheet (mandatory)
         * - rows: number rows in the spritesheet (mandatory)
         * - cutOffFrames: number of sprites not used in the spritesheet (default: 0)
         * - top/bottom/left/right: starting offset position of placeholder element
         * - startSprite: number of the first sprite to show when done loading
         * - onLoaded: callback that will be called when loading has finished
         *
         * Element can be a css selector or existing DOM element or null, in which case a new div element will be created
         *
         * Debug adds logging in console, useful when working on the animation
         *
         * @param {object} options
         * @param {HTMLElement | string} element
         * @param {boolean} debug
         */
        function Spriteling(options, element, debug) {
            if (debug === void 0) { debug = false; }
            var _this = this;
            this.spriteSheet = {
                loaded: false,
                url: null,
                cols: null,
                rows: null,
                cutOffFrames: 0,
                top: null,
                bottom: null,
                left: null,
                right: null,
                startSprite: 1,
                downsizeRatio: 1,
                totalSprites: 0,
                sheetWidth: 0,
                sheetHeight: 0,
                frameWidth: 0,
                frameHeight: 0,
                animations: {},
                onLoaded: null
            };
            /**
             * Stop the current animation and show the specified sprite
             * @param {number} spriteNumber
             */
            this.showSprite = function (spriteNumber) {
                _this.playhead.play = false;
                _this.drawFrame({ sprite: spriteNumber });
            };
            /**
             * Get the current spriteNumber that is shown
             * @returns {number}
             */
            this.currentSprite = function () {
                return _this.playhead.currentSprite;
            };
            /**
             * Add a named animation sequence
             *
             * Name can be any string value
             *
             * Script should be an array of frame objects, each can have the following properties
             * - sprite: which sprite to show (mandatory)
             * - delay: alternate delay then the default delay
             * - top/left/bottom/right: reposition the placeholder element
             *
             * @param {string} name
             * @param {Frame[]} script
             */
            this.addScript = function (name, script) {
                _this.spriteSheet.animations[name] = script;
            };
            /**
             * Resume/play current or given animation.
             * Method can be called in four ways:
             *
             * .play() - resume current animation sequence (if not set - loops over all sprites once)
             * .play(scriptName) - play given animation script
             * .play(scriptName, { options }) - play given animation script with given options
             * .play({ options }) - play current animation with given options
             *
             * ScriptName loads a previously added animation with .addScript()
             *
             * Options object can contain
             * - play: start playing the animation right away (default: true)
             * - run: the number of times the animation should run, -1 is infinite (default: 1)
             * - delay: default delay for all frames that don't have a delay set (default: 50)
             * - tempo: timescale for all delays, double-speed = 2, half-speed = .5 (default:1)
             * - reversed: direction of the animation head, true == backwards (default: false)
             * - script: New unnamed animation sequence, array of frames, see .addScript (default: null)
             * - onPlay/onStop/onFrame/onOutOfView: callbacks called at the appropriate times (default: null)
             *
             * @param {string | Animation} scriptName
             * @param {Animation} options
             * @returns {boolean}
             */
            this.play = function (scriptName, options) {
                // Not yet loaded, wait...
                if (!_this.spriteSheet.loaded) {
                    setTimeout(function () {
                        _this.play(scriptName, options);
                    }, 50);
                    return false;
                }
                // play()
                if (!scriptName && !options) {
                    // Play if not already playing
                    if (!_this.playhead.play) {
                        if (_this.playhead.run === 0) {
                            _this.playhead.run = 1;
                        }
                        _this.playhead.play = true;
                    }
                }
                else {
                    var animationScript = void 0;
                    var animationOptions = {};
                    // play('someAnimation')
                    if (typeof scriptName === 'string' && !options) {
                        if (_this.spriteSheet.animations[scriptName]) {
                            _this.log('info', "playing animation \"" + scriptName + "\"");
                            animationScript = _this.spriteSheet.animations[scriptName];
                        }
                        else {
                            _this.log('error', "animation \"" + scriptName + "\" not found");
                        }
                        // play('someAnimation', { options })
                    }
                    else if (typeof scriptName === 'string' && typeof options === 'object') {
                        animationScript = _this.spriteSheet.animations[scriptName];
                        animationOptions = options;
                        // play({ options })
                    }
                    else if (typeof scriptName === 'object' && !options) {
                        animationScript = _this.playhead.script;
                        animationOptions = scriptName;
                    }
                    if (!animationScript) {
                        _this.log('info', "playing animation \"all\"");
                        animationScript = _this.spriteSheet.animations.all;
                    }
                    _this.playhead = __assign({}, playheadDefaults, { script: animationScript }, animationOptions);
                }
                // Enter the animation loop
                if (_this.playhead.run !== 0) {
                    _this.loop();
                }
                // onPlay callback
                if (typeof _this.playhead.onPlay === 'function') {
                    _this.playhead.onPlay();
                }
            };
            /**
             * Get the current play state
             * @returns {boolean}
             */
            this.isPlaying = function () {
                return _this.playhead.play;
            };
            /**
             * Set playback tempo, double-speed = 2, half-speed = .5 (default:1)
             * @param {number} tempo
             */
            this.setTempo = function (tempo) {
                _this.playhead.tempo = tempo;
            };
            /**
             * Get playback tempo, double-speed = 2, half-speed = .5 (default:1)
             * @returns {number}
             */
            this.getTempo = function () {
                return _this.playhead.tempo;
            };
            /**
             * Step the animation ahead one frame
             * @returns {boolean}
             */
            this.next = function () {
                if (!_this.spriteSheet.loaded) {
                    return false;
                }
                // Update counter
                _this.playhead.currentFrame += 1;
                if (_this.playhead.currentFrame > (_this.playhead.script.length - 1)) {
                    _this.playhead.currentFrame = 0;
                }
                if (_this.playhead.currentFrame === _this.playhead.script.length - 1) {
                    _this.playhead.run -= 1;
                }
                var frame = _this.playhead.script[_this.playhead.currentFrame];
                return _this.drawFrame(frame);
            };
            /**
             * Step the animation backwards one frame
             * @returns {boolean}
             */
            this.previous = function () {
                if (!_this.spriteSheet.loaded) {
                    return false;
                }
                // Update counter
                _this.playhead.currentFrame -= 1;
                if (_this.playhead.currentFrame < 0) {
                    _this.playhead.currentFrame = (_this.playhead.script.length - 1);
                }
                if (_this.playhead.currentFrame === 0) {
                    _this.playhead.run -= 1;
                }
                var frame = _this.playhead.script[_this.playhead.currentFrame];
                return _this.drawFrame(frame);
            };
            /**
             * Jump to certain frame within current animation sequence
             * @param frameNumber [integer]
             * @returns {boolean}
             */
            this.goTo = function (frameNumber) {
                if (!_this.spriteSheet.loaded) {
                    return false;
                }
                // Make sure given frame is within the animation
                var baseNumber = Math.floor(frameNumber / _this.playhead.script.length);
                frameNumber = Math.floor(frameNumber - (baseNumber * _this.playhead.script.length));
                // Draw frame
                _this.playhead.currentFrame = frameNumber;
                var frame = _this.playhead.script[_this.playhead.currentFrame];
                if (typeof frame === undefined) {
                    return false;
                }
                _this.log('info', 'frame: ' + _this.playhead.currentFrame + ', sprite: ' + frame.sprite);
                return _this.drawFrame(frame);
            };
            /**
             * Reverse direction of play
             */
            this.reverse = function () {
                _this.playhead.reversed = !_this.playhead.reversed;
            };
            /**
             * Get the current direction of play
             * @returns {boolean}
             */
            this.isReversed = function () {
                return _this.playhead.reversed;
            };
            /**
             * Stop the animation
             */
            this.stop = function () {
                _this.playhead.play = false;
                // onStop callback
                if (typeof _this.playhead.onStop === 'function') {
                    _this.playhead.onStop();
                }
            };
            /**
             * Reset playhead to first frame
             */
            this.reset = function () {
                _this.goTo(0);
            };
            /**
             * Removes the element and kills the animation loop
             */
            this.destroy = function () {
                _this.playhead.play = false;
                _this.element.parentNode.removeChild(_this.element);
            };
            /**
             * Load the spritesheet and position it correctly
             */
            this.loadSpriteSheet = function () {
                var preload = new Image();
                preload.src = _this.spriteSheet.url;
                imageLoaded(preload, function () {
                    // Fix for some unexplained firefox bug that loads this twice.
                    if (_this.spriteSheet.loaded) {
                        return;
                    }
                    var sheet = _this.spriteSheet;
                    var element = _this.element;
                    sheet.loaded = true;
                    _this.log('info', 'loaded: ' + sheet.url + ', sprites ' + sheet.cols + ' x ' +
                        sheet.rows);
                    sheet.sheetWidth = preload.width;
                    sheet.sheetHeight = preload.height;
                    sheet.frameWidth = sheet.sheetWidth / sheet.cols / sheet.downsizeRatio;
                    sheet.frameHeight = sheet.sheetHeight / sheet.rows / sheet.downsizeRatio;
                    sheet.totalSprites = (sheet.cols * sheet.rows) - sheet.cutOffFrames;
                    if (sheet.frameWidth % 1 !== 0) {
                        _this.log('error', 'frameWidth ' + sheet.frameWidth + ' is not a whole number');
                    }
                    if (sheet.frameHeight % 1 !== 0) {
                        _this.log('error', 'frameHeight ' + sheet.frameHeight + ' is not a whole number');
                    }
                    element.style.position = 'absolute';
                    element.style.width = sheet.frameWidth + "px";
                    element.style.height = sheet.frameHeight + "px";
                    element.style.backgroundImage = "url(" + sheet.url + ")";
                    element.style.backgroundPosition = '0 0';
                    if (sheet.downsizeRatio > 1) {
                        element.style.backgroundSize = sheet.sheetWidth / sheet.downsizeRatio + "px " + sheet.sheetHeight / sheet.downsizeRatio + "px";
                    }
                    if (sheet.top !== null) {
                        if (sheet.top === 'center') {
                            element.style.top = '50%';
                            element.style.marginTop = sheet.frameHeight / 2 * -1 + "px";
                        }
                        else {
                            element.style.top = sheet.top + "px";
                        }
                    }
                    if (sheet.right !== null) {
                        element.style.right = sheet.right + "px";
                    }
                    if (sheet.bottom !== null) {
                        element.style.bottom = sheet.bottom + "px";
                    }
                    if (sheet.left !== null) {
                        if (sheet.left === 'center') {
                            element.style.left = sheet.left + "px";
                            element.style.marginLeft = sheet.frameWidth / 2 * -1 + "px";
                        }
                        else {
                            element.style.left = sheet.left + "px";
                        }
                    }
                    // Auto script the first 'all' animation sequence and make it default
                    _this.autoScript();
                    var animationOptions = { script: sheet.animations.all };
                    _this.playhead = __assign({}, playheadDefaults, animationOptions);
                    // Starting sprite?
                    if (sheet.startSprite > 1 && sheet.startSprite <= sheet.totalSprites) {
                        _this.showSprite(sheet.startSprite);
                    }
                    // onLoaded callback
                    if (typeof sheet.onLoaded === 'function') {
                        sheet.onLoaded();
                    }
                });
            };
            /**
             * Generate a linear script based on the spritesheet itself
             */
            this.autoScript = function () {
                var script = [];
                for (var i = 0; i < _this.spriteSheet.totalSprites; i++) {
                    script[i] = { sprite: (i + 1) };
                }
                _this.addScript('all', script);
            };
            /**
             * The animation loop
             */
            this.loop = function (time) {
                // Should be called as soon as possible
                var requestFrameId = raf_1(_this.loop);
                var sheet = _this.spriteSheet;
                var playhead = _this.playhead;
                var element = _this.element;
                // Wait until fully loaded
                if (element !== null && sheet.loaded) {
                    // Only play when not paused
                    if (playhead.play) {
                        // Throttle on nextDelay
                        if ((time - playhead.lastTime) >= playhead.nextDelay) {
                            // Render next frame only if element is visible and within viewport
                            if (element.offsetParent !== null && _this.inViewport()) {
                                // Only play if run counter is still <> 0
                                if (playhead.run === 0) {
                                    _this.stop();
                                }
                                else {
                                    if (playhead.reversed) {
                                        _this.previous();
                                    }
                                    else {
                                        _this.next();
                                    }
                                    var frame = playhead.script[playhead.currentFrame];
                                    playhead.nextDelay = (frame.delay ? frame.delay : playhead.delay);
                                    playhead.nextDelay /= playhead.tempo;
                                    playhead.lastTime = time;
                                    _this.log('info', 'frame: ' + playhead.currentFrame + ', sprite: ' + frame.sprite + ', delay: ' +
                                        playhead.nextDelay + ', run: ' + playhead.run);
                                }
                            }
                            else {
                                if (typeof playhead.onOutOfView === 'function') {
                                    playhead.onOutOfView();
                                }
                            }
                        }
                    }
                    else {
                        // Cancel animation loop if play = false
                        raf_1.cancel(requestFrameId);
                    }
                }
            };
            /**
             * Draw a single frame
             */
            this.drawFrame = function (frame) {
                var sheet = _this.spriteSheet;
                var playhead = _this.playhead;
                var element = _this.element;
                if (frame.sprite === playhead.currentSprite) {
                    return false;
                }
                var rect = element.getBoundingClientRect();
                var row = Math.ceil(frame.sprite / sheet.cols);
                var col = frame.sprite - ((row - 1) * sheet.cols);
                var bgX = ((col - 1) * sheet.frameWidth) * -1;
                var bgY = ((row - 1) * sheet.frameHeight) * -1;
                if (row > sheet.rows || col > sheet.cols) {
                    _this.log('error', "position " + frame.sprite + " out of bound'");
                }
                // Set sprite
                playhead.currentSprite = frame.sprite;
                // Animate background
                element.style.backgroundPosition = bgX + "px " + bgY + "px";
                // Move if indicated
                if (frame.top) {
                    element.style.top = rect.top + frame.top + "px";
                }
                if (frame.right) {
                    element.style.right = rect.right + frame.right + "px";
                }
                if (frame.bottom) {
                    element.style.bottom = rect.bottom + frame.bottom + "px";
                }
                if (frame.left) {
                    element.style.left = rect.left + frame.left + "px";
                }
                // onFrame callback
                if (typeof playhead.onFrame === 'function') {
                    playhead.onFrame(playhead.currentFrame);
                }
                return true;
            };
            /**
             * Test to see if an element is within the viewport
             * @returns {boolean}
             */
            this.inViewport = function () {
                var sheet = _this.spriteSheet;
                var rect = _this.element.getBoundingClientRect();
                return (rect.top + sheet.frameHeight >= 0 &&
                    rect.left + sheet.frameWidth >= 0 &&
                    rect.bottom - sheet.frameHeight <= (window.innerHeight || document.documentElement.clientHeight) &&
                    rect.right - sheet.frameWidth <= (window.innerWidth || document.documentElement.clientWidth));
            };
            /**
             * Log utility method
             * @param level
             * @param message
             * @private
             */
            this.log = function (level, message) {
                if (typeof console === 'undefined' || (level === 'info' && !_this.debug)) {
                    return;
                }
                console[level]("Spriteling: " + message);
            };
            // Lookup element by selector
            if (element) {
                this.element = typeof element === 'string' ? document.querySelector(element) : element;
            }
            // No element found, let's create one instead
            if (!this.element) {
                if (typeof this.element !== 'undefined') {
                    this.log('warn', "element \"" + element + "\" not found, created new element instead");
                }
                this.element = document.createElement('div');
                document.body.appendChild(this.element);
            }
            // Combine options with defaults
            this.spriteSheet = __assign({}, this.spriteSheet, options);
            this.playhead = __assign({}, playheadDefaults);
            this.debug = debug;
            // Initialize spritesheet
            if (!options.cols) {
                this.log('error', 'options.cols not set');
            }
            if (!options.rows) {
                this.log('error', 'options.rows not set');
            }
            if (!options.url) {
                // If no sprite is specified try to use background-image
                var elementStyle = window.getComputedStyle(this.element);
                var cssBackgroundImage = elementStyle.getPropertyValue('background-image');
                if (cssBackgroundImage === 'none') {
                    this.log('error', 'no spritesheet image found, please specify it with options.url or set as css background');
                }
                else {
                    this.spriteSheet.url = cssBackgroundImage.replace(/"/g, '').replace(/url\(|\)$/ig, '');
                }
            }
            this.loadSpriteSheet();
        }
        return Spriteling;
    }());

    return Spriteling;

})));
