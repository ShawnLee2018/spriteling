'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
  return typeof obj;
} : function (obj) {
  return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
};

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var imageLoaded = require('image-loaded');
var raf = require('raf');

var Spriteling = function () {

  /**
   * @options: object to override global options with, the following properties can be set
   *           - debug: show debug logging in console (default: false)
   *           - url: url to spriteSheet, if not set the css background-image will be used
   *           - cols: number columns in the spritesheet (mandatory)
   *           - rows: number rows in the spritesheet (mandatory)
   *           - cutOffFrames: number of sprites not used in the spritesheet (default: 0)
   *           - top/bottom/left/right: starting offset position
   *           - startSprite: number of the first sprite to show when done loading
   *           - onLoaded: callback that will be called when loading has finished
   * @element: can be a css selector or DOM element or false (in which case a new div element will be created)
   */

  function Spriteling(options) {
    var _this = this;

    var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    classCallCheck(this, Spriteling);
    this.spriteDefaults = {
      debug: false,
      url: null,
      cols: null,
      rows: null,
      cutOffFrames: 0,
      top: null,
      bottom: null,
      left: null,
      right: null,
      startSprite: 1,
      onLoaded: null
    };
    this.animationDefaults = {
      play: true,
      delay: 50,
      tempo: 1,
      run: 1,
      reversed: false,
      outOfViewStop: false,
      script: [],
      lastTime: 0,
      nextDelay: 0,
      currentFrame: -1,
      currentSprite: 1,
      onPlay: null,
      onStop: null,
      onFrame: null
    };
    this._internal = {
      loaded: false,
      totalSprites: 0,
      sheetWidth: 0,
      sheetHeight: 0,
      frameWidth: 0,
      frameHeight: 0,
      animations: {}
    };
    this._options = {};
    this._playhead = {};
    this._element = false;

    this._loop = function (time) {
      // Should be called as soon as possible
      var requestFrameId = raf(_this._loop);

      //console.log(requestFrameId);

      // Wait until fully loaded
      if (_this._element !== null && _this._internal.loaded) {

        // Only play when not paused
        if (_this._playhead.play) {

          // Throttle on nextDelay
          if (time - _this._playhead.lastTime >= _this._playhead.nextDelay) {

            // Render next frame only if element is visible and within viewport
            if (_this._element.offsetParent !== null) {
              // && _inViewport(this._element)

              // Only play if run counter is still <> 0
              if (_this._playhead.run === 0) {
                _this.stop();
              } else {

                if (_this._playhead.reversed) {
                  _this.previous();
                } else {
                  _this.next();
                }

                var frame = _this._playhead.script[_this._playhead.currentFrame];
                _this._playhead.nextDelay = frame.delay ? frame.delay : _this._playhead.delay;
                _this._playhead.nextDelay /= _this._playhead.tempo;
                _this._playhead.lastTime = time;

                _this._log('info', 'frame: ' + _this._playhead.currentFrame + ', sprite: ' + frame.sprite + ', delay: ' + _this._playhead.nextDelay + ', run: ' + _this._playhead.run);
              }
            } else {
              if (_this._playhead.outOfViewStop) {
                _this.stop();
              }
            }
          }
        } else {
          // Cancel animation loop if play = false
          raf.cancel(requestFrameId);
        }
      }
    };

    // Lookup element by selector
    if (element) {
      this._element = element instanceof Element ? element : document.querySelector(element);
      if (!this._element || !this._element instanceof Element) {
        this._log('warn', 'element "' + element + '" not found, created new element instead');
      }
    }

    // No element found, let's create one instead
    if (!this._element) {
      this._element = document.createElement('div');
      this._element.style.cssText = 'position: absolute; top: 0; left: 0; z-index: 10000; color: blue; border: 10px solid red; width: 100px; height: 100px;';
      document.body.appendChild(this._element);
    }

    // Combine options with defaults
    this._options = Object.assign({}, this.spriteDefaults, options);

    // Initialize spritesheet
    if (!options.cols) {
      this._log('error', 'options.cols not set');
    }
    if (!options.rows) {
      this._log('error', 'options.rows not set');
    }
    if (!options.url) {
      // If no sprite is specified try to use background-image
      var elementStyle = window.getComputedStyle(this._element);
      var cssBackgroundImage = elementStyle.getPropertyValue('background-image');
      if (cssBackgroundImage === 'none') {
        this._log('error', 'no spritesheet image found, please specify it with options.url or set with css as background');
      } else {
        this._options.url = cssBackgroundImage.replace(/"/g, '').replace(/url\(|\)$/ig, '');
      }
    }

    this._load();
    console.log(this._options.url);
    console.log('@', element, this._element);
  }

  /**
   * Show certain sprite (circumvents the current animation sequence)
   */


  createClass(Spriteling, [{
    key: 'showSprite',
    value: function showSprite(spriteNumber) {
      this._playhead.play = false;
      this._drawFrame({ sprite: spriteNumber });
    }

    /**
     * Get the current spriteNumber that is shown
     */

  }, {
    key: 'currentSprite',
    value: function currentSprite() {
      return this._playhead.currentSprite;
    }

    /**
     * Add a named animation sequence
     * @name: string
     * @script: array with objects as frames, eg [{sprite: 1, delay: 200}, {sprite: 3, top:1 }]
     *          each frame can have the following properties
     *          - sprite: which sprite to show (mandatory)
     *          - delay: alternate delay then the default delay
     *          - top/left/bottom/right: reposition the placeholder
     */

  }, {
    key: 'addScript',
    value: function addScript(name, script) {
      // TODO: type validation
      this._internal.animations[name] = script;
    }
  }, {
    key: 'setTempo',
    value: function setTempo(tempo) {
      this._playhead.tempo = tempo;
    }

    /**
     * Get the current frame
     */

  }, {
    key: 'current',
    value: function current() {
      return this._playhead.currentFrame;
    }

    /**
     * Go forward one frame
     */

  }, {
    key: 'next',
    value: function next() {
      if (!this._internal.loaded) {
        return false;
      }

      // Update counter
      this._playhead.currentFrame += 1;
      if (this._playhead.currentFrame > this._playhead.script.length - 1) {
        this._playhead.currentFrame = 0;
      }
      if (this._playhead.currentFrame === this._playhead.script.length - 1) {
        this._playhead.run -= 1;
      }

      var frame = this._playhead.script[this._playhead.currentFrame];
      this._drawFrame(frame);
    }

    /**
     * Go back one frame
     */

  }, {
    key: 'previous',
    value: function previous() {
      if (!this._internal.loaded) {
        return false;
      }

      // Update counter
      this._playhead.currentFrame -= 1;
      if (this._playhead.currentFrame < 0) {
        this._playhead.currentFrame = this._playhead.script.length - 1;
      }
      if (this._playhead.currentFrame === 0) {
        this._playhead.run -= 1;
      }

      var frame = this._playhead.script[this._playhead.currentFrame];
      this._drawFrame(frame);
    }

    /**
     * Jump to certain frame within current animation sequence
     * @param frameNumber [integer]
     * @returns {boolean}
     */

  }, {
    key: 'goTo',
    value: function goTo(frameNumber) {
      if (!this._internal.loaded) {
        return false;
      }

      // Make sure given framenumber is within the animation
      var _baseNumber = Math.floor(frameNumber / this._playhead.script.length);
      frameNumber = Math.floor(frameNumber - _baseNumber * this._playhead.script.length);

      // Draw frame
      this._playhead.currentFrame = frameNumber;
      var frame = this._playhead.script[this._playhead.currentFrame];
      if (frame !== undefined) {
        this._log('info', 'frame: ' + this._playhead.currentFrame + ', sprite: ' + frame.sprite);
        this._drawFrame(frame);
      }
    }

    /**
     * Define a new animation sequence or resume if not playing
     * @animationObject:
     *          if object with animation settings, the following are allowed
     *              - play: start playing the animation right away (default: true)
     *              - run: the number of times the animation should run, -1 is infinite (default: 1)
     *              - delay: default delay for all frames that don't have a delay set (default: 50)
     *              - tempo: timescale for all delays, double-speed = 2, half-speed = .5 (default:1)
     *              - reversed: direction of the animation head, true == backwards (default: false)
     *              - outOfViewStop: stop animation if placeholder is no longer in view (default: false)
     *              - script: new animation array or string (in which case animation sequence is looked up)
     *              - onPlay/onStop/onFrame: callbacks called at the appropriate times (default: null)
     *          if not set, we resume the current animation or start the 'all' built-in animation sequence
     */

  }, {
    key: 'play',
    value: function play(animationObject) {
      var _this2 = this;

      // Not yet loaded, wait...
      if (!this._internal.loaded) {
        setTimeout(function () {
          _this2._play(animationObject);
        }, 50);
        return false;
      }

      if ((typeof animationObject === 'undefined' ? 'undefined' : _typeof(animationObject)) === 'object') {
        if (typeof animationObject.script === 'string') {
          // Resolve to stored animation sequence
          animationObject.script = this._internal.animations[animationObject.script];
        }
        if (typeof animationObject.script === 'undefined') {
          animationObject.script = this._internal.animations['all'];
        }
        this._playhead = Object.assign({}, this.animationDefaults, animationObject);
      } else {
        if (!this._playhead.play) {
          if (this._playhead.run === 0) {
            this._playhead.run = 1;
          }
          this._playhead.play = true;
          this._loop();
        }
      }

      // Enter the animation loop
      if (this._playhead.run !== 0) {
        this._loop();
      }

      // onPlay callback
      if (typeof this._playhead.onPlay === 'function') {
        this._.playhead.onPlay.call($element.data('spriteAnimator'));
      }
    }

    /**
     * Reverse direction of play
     */

  }, {
    key: 'reverse',
    value: function reverse() {
      this._playhead.reversed = !this._playhead.reversed;
    }

    /**
     * Stop the animation
     */

  }, {
    key: 'stop',
    value: function stop() {
      this._playhead.play = false;

      // onStop callback
      // if (typeof plugin.playhead.onStop === 'function') {
      //   plugin.playhead.onStop.call($element.data('spriteAnimator'));
      // }
    }

    /**
     * Reset playhead to first frame
     */

  }, {
    key: 'reset',
    value: function reset() {
      this.goTo(0);
    }

    /**
     * Load the spritesheet and position it correctly
     */

  }, {
    key: '_load',
    value: function _load() {
      var _this3 = this;

      var _preload = new Image();
      _preload.src = this._options.url;

      imageLoaded(_preload, function () {
        if (_this3._internal.loaded) {
          return;
        } // <- Fix for some unexplained firefox bug that loads this twice.
        _this3._internal.loaded = true;

        _this3._log('info', 'Loaded: ' + _this3._options.url + ', sprites ' + _this3._options.cols + ' x ' + _this3._options.rows);

        _this3._internal.sheetWidth = _preload.width;
        _this3._internal.sheetHeight = _preload.height;
        _this3._internal.frameWidth = parseInt(_this3._internal.sheetWidth / _this3._options.cols, 10);
        _this3._internal.frameHeight = parseInt(_this3._internal.sheetHeight / _this3._options.rows, 10);
        _this3._internal.totalSprites = _this3._options.cols * _this3._options.rows - _this3._options.cutOffFrames;

        if (_this3._internal.frameWidth % 1 !== 0) {
          _this3._log('error', 'frameWidth ' + _this3._internal.frameWidth + ' is not a whole number');
        }
        if (_this3._internal.frameHeight % 1 !== 0) {
          _this3._log('error', 'frameHeight ' + _this3._internal.frameHeight + ' is not a whole number');
        }

        _this3._element.setAttribute('style', '\n        position: absolute;\n        width: ' + _this3._internal.frameWidth + ';\n        height: ' + _this3._internal.frameHeight + ';\n        background-image: \'url(' + _this3._options.url + ')\';\n        background-position: \'0 0\';\n      ');

        if (_this3._options.top !== null) {
          if (_this3._options.top === 'center') {
            _this3._element.setAttribute('style', '\n            top: 50%;\n            margin-top: ' + _this3._internal.frameHeight / 2 * -1 + ';\n          ');
          } else {
            _this3._element.setAttribute('style', 'top: ' + _this3._options.top + ';');
          }
        }
        if (_this3._options.right !== null) {
          _this3._element.setAttribute('style', 'right: ' + _this3._options.right + ';');
        }
        if (_this3._options.bottom !== null) {
          _this3._element.setAttribute('style', 'bottom: ' + _this3._options.bottom + ';');
        }
        if (_this3._options.left !== null) {
          if (_this3._options.left === 'center') {
            _this3._element.setAttribute('style', '\n            left: ' + _this3._options.left + ';\n            margin-left: ' + _this3._internal.frameWidth / 2 * -1 + ';\n          ');
          } else {
            _this3._element.setAttribute('style', 'left: ' + _this3._options.left + ';');
          }
        }

        // Auto script the first 'all' animation sequence and make it default
        _this3._autoScript();
        var animationObject = { script: _this3._internal.animations['all'] };
        _this3.playhead = Object.assign({}, _this3.animationDefaults, animationObject);

        // Starting sprite?
        if (_this3._options.startSprite > 1 && _this3._options.startSprite <= _this3._internal.totalSprites) {
          _this3.showSprite(_this3._options.startSprite);
        }

        // onLoaded callback
        // if (typeof this._options.onLoaded === 'function') {
        //   this._options.onLoaded.call($element.data('spriteAnimator'))
        // }
      });
    }

    /**
     * Generate a linear script based on the spritesheet itself
     */

  }, {
    key: '_autoScript',
    value: function _autoScript() {
      var script = [];
      for (var i = 0; i < this._internal.totalSprites; i++) {
        script[i] = { sprite: i + 1 };
      }
      this.addScript('all', script);
    }

    /**
     * The animation loop
     */

  }, {
    key: '_drawFrame',


    /**
     * Draw a single frame
     */
    value: function _drawFrame(frame) {
      if (frame.sprite === this._playhead.currentSprite) {
        return false;
      }
      this._playhead.currentSprite = frame.sprite;

      var row = Math.ceil(frame.sprite / this._options.cols);
      var col = frame.sprite - (row - 1) * this._options.cols;
      var bgX = (col - 1) * this._internal.frameWidth * -1;
      var bgY = (row - 1) * this._internal.frameHeight * -1;

      if (row > this._options.rows || col > this._options.cols) {
        this._log('error', 'position ' + frame.sprite + ' out of bound\'');
      }

      // Animate background
      this._element.setAttribute('style', 'background-position: ' + bgX + 'px ' + bgY + 'px;');
      var rect = this._element.getBoundingClientRect();

      // Move if indicated
      if (frame.top) {
        this._element.setAttribute('style', 'top: ' + (rect.top + frame.top) + 'px;');
      }
      if (frame.right) {
        this._element.setAttribute('style', 'right: ' + (rect.right + frame.right) + 'px;');
      }
      if (frame.bottom) {
        this._element.setAttribute('style', 'bottom: ' + (rect.bottom + frame.bottom) + 'px;');
      }
      if (frame.left) {
        this._element.setAttribute('style', 'left: ' + (rect.left + frame.left) + 'px;');
      }

      // onFrame callback
      // if (typeof this._playhead.onFrame === 'function') {
      //   this._playhead.onFrame.call($element.data('spriteAnimator'))
      // }
    }

    /**
     * Log utility method
     * @param level
     * @param message
     * @private
     */

  }, {
    key: '_log',
    value: function _log(level, message) {
      console[level]('SpriteLing: ' + message);
    }
  }]);
  return Spriteling;
}();

module.exports = Spriteling;
