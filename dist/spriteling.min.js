(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.SpriteLing = factory());
}(this, (function () { 'use strict';

  /*
   * Modified version of http://github.com/desandro/imagesloaded v2.1.1
   * MIT License. by Paul Irish et al.
   */

  var BLANK = 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==';

  function loaded(image, callback) {
    var src
      , old
      ;

    if (!image.nodeName) return callback(new Error('First argument must be an image element'))
    if (image.nodeName.toLowerCase() !== 'img') return callback(new Error('Element supplied is not an image'))
    if (image.src  && image.complete && image.naturalWidth !== undefined) return callback(null, true)

    old = !image.addEventListener;

    function loaded() {
      if (old) {
        image.detachEvent('onload', loaded);
      } else {
        image.removeEventListener('load', loaded, false);
      }
      callback(null, false);
    }

    if (old) {
      image.attachEvent('onload', loaded);
    } else {
      image.addEventListener('load', loaded, false);
    }

    if (image.readyState || image.complete) {
      src = image.src;
      image.src = BLANK;
      image.src = src;
    }
  }

  var imageLoaded = loaded;

  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  var performanceNow = createCommonjsModule(function (module) {
  // Generated by CoffeeScript 1.12.2
  (function() {
    var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

    if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
      module.exports = function() {
        return performance.now();
      };
    } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
      module.exports = function() {
        return (getNanoSeconds() - nodeLoadTime) / 1e6;
      };
      hrtime = process.hrtime;
      getNanoSeconds = function() {
        var hr;
        hr = hrtime();
        return hr[0] * 1e9 + hr[1];
      };
      moduleLoadTime = getNanoSeconds();
      upTime = process.uptime() * 1e9;
      nodeLoadTime = moduleLoadTime - upTime;
    } else if (Date.now) {
      module.exports = function() {
        return Date.now() - loadTime;
      };
      loadTime = Date.now();
    } else {
      module.exports = function() {
        return new Date().getTime() - loadTime;
      };
      loadTime = new Date().getTime();
    }

  }).call(commonjsGlobal);

  //# sourceMappingURL=performance-now.js.map
  });

  var root = typeof window === 'undefined' ? commonjsGlobal : window
    , vendors = ['moz', 'webkit']
    , suffix = 'AnimationFrame'
    , raf = root['request' + suffix]
    , caf = root['cancel' + suffix] || root['cancelRequest' + suffix];

  for(var i = 0; !raf && i < vendors.length; i++) {
    raf = root[vendors[i] + 'Request' + suffix];
    caf = root[vendors[i] + 'Cancel' + suffix]
        || root[vendors[i] + 'CancelRequest' + suffix];
  }

  // Some versions of FF have rAF but not cAF
  if(!raf || !caf) {
    var last = 0
      , id = 0
      , queue = []
      , frameDuration = 1000 / 60;

    raf = function(callback) {
      if(queue.length === 0) {
        var _now = performanceNow()
          , next = Math.max(0, frameDuration - (_now - last));
        last = next + _now;
        setTimeout(function() {
          var cp = queue.slice(0);
          // Clear queue here to prevent
          // callbacks from appending listeners
          // to the current frame's queue
          queue.length = 0;
          for(var i = 0; i < cp.length; i++) {
            if(!cp[i].cancelled) {
              try{
                cp[i].callback(last);
              } catch(e) {
                setTimeout(function() { throw e }, 0);
              }
            }
          }
        }, Math.round(next));
      }
      queue.push({
        handle: ++id,
        callback: callback,
        cancelled: false
      });
      return id
    };

    caf = function(handle) {
      for(var i = 0; i < queue.length; i++) {
        if(queue[i].handle === handle) {
          queue[i].cancelled = true;
        }
      }
    };
  }

  var raf_1 = function(fn) {
    // Wrap in a new function to prevent
    // `cancel` potentially being assigned
    // to the native rAF function
    return raf.call(root, fn)
  };
  var cancel = function() {
    caf.apply(root, arguments);
  };
  var polyfill = function(object) {
    if (!object) {
      object = root;
    }
    object.requestAnimationFrame = raf;
    object.cancelAnimationFrame = caf;
  };
  raf_1.cancel = cancel;
  raf_1.polyfill = polyfill;

  var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  };

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var Spriteling =

  /**
   * @options: object to override global options with, the following properties can be set
   *           - debug: show debug logging in console (default: false)
   *           - url: url to spriteSheet, if not set the css background-image will be used
   *           - cols: number columns in the spritesheet (mandatory)
   *           - rows: number rows in the spritesheet (mandatory)
   *           - cutOffFrames: number of sprites not used in the spritesheet (default: 0)
   *           - top/bottom/left/right: starting offset position
   *           - startSprite: number of the first sprite to show when done loading
   *           - onLoaded: callback that will be called when loading has finished
   * @element: can be a css selector or DOM element or false (in which case a new div element will be created)
   */

  function Spriteling(options) {
    var _this = this;

    var element = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    classCallCheck(this, Spriteling);
    this.spriteDefaults = {
      debug: false,
      url: null,
      cols: null,
      rows: null,
      cutOffFrames: 0,
      top: null,
      bottom: null,
      left: null,
      right: null,
      startSprite: 1,
      onLoaded: null
    };
    this.animationDefaults = {
      play: true,
      delay: 50,
      tempo: 1,
      run: 1,
      reversed: false,
      outOfViewStop: false,
      script: [],
      lastTime: 0,
      nextDelay: 0,
      currentFrame: -1,
      currentSprite: 1,
      onPlay: null,
      onStop: null,
      onFrame: null
    };
    this._internal = {
      loaded: false,
      totalSprites: 0,
      sheetWidth: 0,
      sheetHeight: 0,
      frameWidth: 0,
      frameHeight: 0,
      animations: {}
    };
    this._options = {};
    this._playhead = {};
    this._element = false;

    this.showSprite = function (spriteNumber) {
      _this._playhead.play = false;
      _this._drawFrame({ sprite: spriteNumber });
    };

    this.currentSprite = function () {
      return _this._playhead.currentSprite;
    };

    this.addScript = function (name, script) {
      _this._internal.animations[name] = script;
    };

    this.setTempo = function (tempo) {
      _this._playhead.tempo = tempo;
    };

    this.current = function () {
      return _this._playhead.currentFrame;
    };

    this.next = function () {
      if (!_this._internal.loaded) {
        return false;
      }

      // Update counter
      _this._playhead.currentFrame += 1;
      if (_this._playhead.currentFrame > _this._playhead.script.length - 1) {
        _this._playhead.currentFrame = 0;
      }
      if (_this._playhead.currentFrame === _this._playhead.script.length - 1) {
        _this._playhead.run -= 1;
      }

      var frame = _this._playhead.script[_this._playhead.currentFrame];
      _this._drawFrame(frame);
    };

    this.previous = function () {
      if (!_this._internal.loaded) {
        return false;
      }

      // Update counter
      _this._playhead.currentFrame -= 1;
      if (_this._playhead.currentFrame < 0) {
        _this._playhead.currentFrame = _this._playhead.script.length - 1;
      }
      if (_this._playhead.currentFrame === 0) {
        _this._playhead.run -= 1;
      }

      var frame = _this._playhead.script[_this._playhead.currentFrame];
      _this._drawFrame(frame);
    };

    this.goTo = function (frameNumber) {
      if (!_this._internal.loaded) {
        return false;
      }

      // Make sure given framenumber is within the animation
      var _baseNumber = Math.floor(frameNumber / _this._playhead.script.length);
      frameNumber = Math.floor(frameNumber - _baseNumber * _this._playhead.script.length);

      // Draw frame
      _this._playhead.currentFrame = frameNumber;
      var frame = _this._playhead.script[_this._playhead.currentFrame];
      if (frame !== undefined) {
        _this._log('info', 'frame: ' + _this._playhead.currentFrame + ', sprite: ' + frame.sprite);
        _this._drawFrame(frame);
      }
    };

    this.play = function (scriptName) {
      var animationObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      // Not yet loaded, wait...
      if (!_this._internal.loaded) {
        setTimeout(function () {
          _this.play(scriptName, animationObject);
        }, 50);
        return false;
      }

      if (scriptName) {
        // Script provided
        if (typeof scriptName === 'string') {
          animationObject.script = scriptName;
        }

        // No script provided
        if ((typeof scriptName === 'undefined' ? 'undefined' : _typeof(scriptName)) === 'object') {
          animationObject = scriptName;
        }

        // Resolve animation script
        if ((typeof animationObject === 'undefined' ? 'undefined' : _typeof(animationObject)) === 'object') {
          var _scriptName = animationObject.script;
          if (typeof _scriptName === 'string') {
            animationObject.script = _this._internal.animations[_scriptName];
          }
          if (typeof _scriptName === 'undefined') {
            animationObject.script = _this._internal.animations['all'];
          }
          _this._log('info', 'playing animation "' + _scriptName + '"');
          _this._playhead = Object.assign({}, _this.animationDefaults, animationObject);
        }
      } else {
        // Play if not already playing
        if (!_this._playhead.play) {
          if (_this._playhead.run === 0) {
            _this._playhead.run = 1;
          }
          _this._playhead.play = true;
          _this._loop();
        }
      }

      // Enter the animation loop
      if (_this._playhead.run !== 0) {
        _this._loop();
      }

      // onPlay callback
      if (typeof _this._playhead.onPlay === 'function') {
        _this._.playhead.onPlay();
      }
    };

    this.reverse = function () {
      _this._playhead.reversed = !_this._playhead.reversed;
    };

    this.stop = function () {
      _this._playhead.play = false;

      // onStop callback
      if (typeof _this._playhead.onStop === 'function') {
        _this._playhead.onStop();
      }
    };

    this.reset = function () {
      _this.goTo(0);
    };

    this._loadSpriteSheet = function () {
      var _preload = new Image();
      _preload.src = _this._options.url;

      imageLoaded(_preload, function () {
        if (_this._internal.loaded) {
          return;
        } // <- Fix for some unexplained firefox bug that loads this twice.
        _this._internal.loaded = true;

        _this._log('info', 'loaded: ' + _this._options.url + ', sprites ' + _this._options.cols + ' x ' + _this._options.rows);

        _this._internal.sheetWidth = _preload.width;
        _this._internal.sheetHeight = _preload.height;
        _this._internal.frameWidth = parseInt(_this._internal.sheetWidth / _this._options.cols, 10);
        _this._internal.frameHeight = parseInt(_this._internal.sheetHeight / _this._options.rows, 10);
        _this._internal.totalSprites = _this._options.cols * _this._options.rows - _this._options.cutOffFrames;

        if (_this._internal.frameWidth % 1 !== 0) {
          _this._log('error', 'frameWidth ' + _this._internal.frameWidth + ' is not a whole number');
        }
        if (_this._internal.frameHeight % 1 !== 0) {
          _this._log('error', 'frameHeight ' + _this._internal.frameHeight + ' is not a whole number');
        }

        _this._element.style.position = 'absolute';
        _this._element.style.width = _this._internal.frameWidth + 'px';
        _this._element.style.height = _this._internal.frameHeight + 'px';
        _this._element.style.backgroundImage = 'url(' + _this._options.url + ')';
        _this._element.style.backgroundPosition = '0 0';

        if (_this._options.top !== null) {
          if (_this._options.top === 'center') {

            _this._element.style.top = '50%';
            _this._element.style.marginTop = _this._internal.frameHeight / 2 * -1 + 'px';
          } else {
            _this._element.style.top = _this._options.top + 'px';
          }
        }
        if (_this._options.right !== null) {
          _this._element.style.right = _this._options.right + 'px';
        }
        if (_this._options.bottom !== null) {
          _this._element.style.bottom = _this._options.bottom + 'px';
        }
        if (_this._options.left !== null) {
          if (_this._options.left === 'center') {
            _this._element.style.left = _this._options.left + 'px';
            _this._element.style.marginLeft = _this._internal.frameWidth / 2 * -1 + 'px';
          } else {
            _this._element.style.left = _this._options.left + 'px';
          }
        }

        // Auto script the first 'all' animation sequence and make it default
        _this._autoScript();
        var animationObject = { script: _this._internal.animations['all'] };
        _this.playhead = Object.assign({}, _this.animationDefaults, animationObject);

        // Starting sprite?
        if (_this._options.startSprite > 1 && _this._options.startSprite <= _this._internal.totalSprites) {
          _this.showSprite(_this._options.startSprite);
        }

        // onLoaded callback
        if (typeof _this._options.onLoaded === 'function') {
          _this._options.onLoaded();
        }
      });
    };

    this._autoScript = function () {
      var script = [];
      for (var i = 0; i < _this._internal.totalSprites; i++) {
        script[i] = { sprite: i + 1 };
      }
      _this.addScript('all', script);
    };

    this._loop = function (time) {
      // Should be called as soon as possible
      var requestFrameId = raf_1(_this._loop);

      // Wait until fully loaded
      if (_this._element !== null && _this._internal.loaded) {

        // Only play when not paused
        if (_this._playhead.play) {

          // Throttle on nextDelay
          if (time - _this._playhead.lastTime >= _this._playhead.nextDelay) {

            // Render next frame only if element is visible and within viewport
            if (_this._element.offsetParent !== null) {
              // && _inViewport(this._element)

              // Only play if run counter is still <> 0
              if (_this._playhead.run === 0) {
                _this.stop();
              } else {

                if (_this._playhead.reversed) {
                  _this.previous();
                } else {
                  _this.next();
                }

                var frame = _this._playhead.script[_this._playhead.currentFrame];
                _this._playhead.nextDelay = frame.delay ? frame.delay : _this._playhead.delay;
                _this._playhead.nextDelay /= _this._playhead.tempo;
                _this._playhead.lastTime = time;

                _this._log('info', 'frame: ' + _this._playhead.currentFrame + ', sprite: ' + frame.sprite + ', delay: ' + _this._playhead.nextDelay + ', run: ' + _this._playhead.run);
              }
            } else {
              if (_this._playhead.outOfViewStop) {
                _this.stop();
              }
            }
          }
        } else {
          // Cancel animation loop if play = false
          raf_1.cancel(requestFrameId);
        }
      }
    };

    this._drawFrame = function (frame) {
      if (frame.sprite === _this._playhead.currentSprite) {
        return false;
      }
      _this._playhead.currentSprite = frame.sprite;

      var row = Math.ceil(frame.sprite / _this._options.cols);
      var col = frame.sprite - (row - 1) * _this._options.cols;
      var bgX = (col - 1) * _this._internal.frameWidth * -1;
      var bgY = (row - 1) * _this._internal.frameHeight * -1;

      if (row > _this._options.rows || col > _this._options.cols) {
        _this._log('error', 'position ' + frame.sprite + ' out of bound\'');
      }

      // Animate background
      _this._element.style.backgroundPosition = bgX + 'px ' + bgY + 'px';
      var rect = _this._element.getBoundingClientRect();

      // Move if indicated
      if (frame.top) {
        _this._element.style.top = rect.top + frame.top + 'px';
      }
      if (frame.right) {
        _this._element.style.top = rect.right + frame.right + 'px';
      }
      if (frame.bottom) {
        _this._element.style.top = rect.bottom + frame.bottom + 'px';
      }
      if (frame.left) {
        _this._element.style.top = rect.left + frame.left + 'px';
      }

      // onFrame callback
      if (typeof _this._playhead.onFrame === 'function') {
        _this._playhead.onFrame();
      }
    };

    this._log = function (level, message) {
      if (level === 'info' && !_this._options.debug) return;
      console[level]('SpriteLing: ' + message);
    };

    // Lookup element by selector
    if (element) {
      this._element = element instanceof Element ? element : document.querySelector(element);
      if (!this._element || !this._element instanceof Element) {
        this._log('warn', 'element "' + element + '" not found, created new element instead');
      }
    }

    // No element found, let's create one instead
    if (!this._element) {
      this._element = document.createElement('div');
      document.body.appendChild(this._element);
    }

    // Combine options with defaults
    this._options = Object.assign({}, this.spriteDefaults, options);

    // Initialize spritesheet
    if (!options.cols) {
      this._log('error', 'options.cols not set');
    }
    if (!options.rows) {
      this._log('error', 'options.rows not set');
    }
    if (!options.url) {
      // If no sprite is specified try to use background-image
      var elementStyle = window.getComputedStyle(this._element);
      var cssBackgroundImage = elementStyle.getPropertyValue('background-image');
      if (cssBackgroundImage === 'none') {
        this._log('error', 'no spritesheet image found, please specify it with options.url or set with css as background');
      } else {
        this._options.url = cssBackgroundImage.replace(/"/g, '').replace(/url\(|\)$/ig, '');
      }
    }

    this._loadSpriteSheet();
  }

  /**
   * Show certain sprite (circumvents the current animation sequence)
   */


  /**
   * Get the current spriteNumber that is shown
   */


  /**
   * Add a named animation sequence
   * @name: string
   * @script: array with objects as frames, eg [{sprite: 1, delay: 200}, {sprite: 3, top:1 }]
   *          each frame can have the following properties
   *          - sprite: which sprite to show (mandatory)
   *          - delay: alternate delay then the default delay
   *          - top/left/bottom/right: reposition the placeholder
   */


  /**
   * Get the current frame
   */


  /**
   * Go forward one frame
   */


  /**
   * Go back one frame
   */


  /**
   * Jump to certain frame within current animation sequence
   * @param frameNumber [integer]
   * @returns {boolean}
   */


  /**
   * Define a new animation sequence or resume if not playing
   * @animationObject:
   *          if object with animation settings, the following are allowed
   *              - play: start playing the animation right away (default: true)
   *              - run: the number of times the animation should run, -1 is infinite (default: 1)
   *              - delay: default delay for all frames that don't have a delay set (default: 50)
   *              - tempo: timescale for all delays, double-speed = 2, half-speed = .5 (default:1)
   *              - reversed: direction of the animation head, true == backwards (default: false)
   *              - outOfViewStop: stop animation if placeholder is no longer in view (default: false)
   *              - script: new animation array or string (in which case animation sequence is looked up)
   *              - onPlay/onStop/onFrame: callbacks called at the appropriate times (default: null)
   *          if not set, we resume the current animation or start the 'all' built-in animation sequence
   */


  /**
   * Reverse direction of play
   */


  /**
   * Stop the animation
   */


  /**
   * Reset playhead to first frame
   */


  /**
   * Load the spritesheet and position it correctly
   */


  /**
   * Generate a linear script based on the spritesheet itself
   */


  /**
   * The animation loop
   */


  /**
   * Draw a single frame
   */


  /**
   * Log utility method
   * @param level
   * @param message
   * @private
   */
  ;

  return Spriteling;

})));
